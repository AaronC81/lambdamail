# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/dm-core/all/dm-core.rbi
#
# dm-core-1.2.1
module DataMapper
  def self.finalize; end
  def self.logger; end
  def self.logger=(arg0); end
  def self.repository(name = nil); end
  def self.root; end
  def self.setup(*args); end
  extend DataMapper::Assertions
end
module DataMapper::Ext
  def self.blank?(value); end
  def self.try_dup(value); end
end
module DataMapper::Ext::Hash
  def self.except!(hash, *keys); end
  def self.except(hash, *keys); end
  def self.only(hash, *keys); end
  def self.to_mash(hash); end
end
module DataMapper::Ext::Object
  def self.full_const_get(obj, name = nil); end
  def self.full_const_set(obj, name, value = nil); end
end
module DataMapper::Ext::String
  def self.compress_lines(string, spaced = nil); end
end
class Pathname
  def to_str; end
end
module DataMapper::Ext::Module
  def self.find_const(mod, const_name); end
  def self.nested_const_lookup(mod, const_name); end
end
module DataMapper::Ext::Array
  def self.to_mash(array); end
end
class DataMapper::Mash < Hash
  def []=(key, value); end
  def convert_key(key); end
  def convert_value(value); end
  def default(key = nil); end
  def delete(key); end
  def except!(*keys); end
  def except(*keys); end
  def fetch(key, *extras); end
  def has_key?(key); end
  def include?(key); end
  def initialize(constructor = nil); end
  def key?(key); end
  def member?(key); end
  def merge!(other_hash); end
  def merge(hash); end
  def regular_update(arg0); end
  def regular_writer(arg0, arg1); end
  def stringify_keys!; end
  def symbolize_keys; end
  def to_hash; end
  def update(other_hash); end
  def values_at(*indices); end
end
module DataMapper::Inflector
  def camelize(lower_case_and_underscored_word, first_letter_in_uppercase = nil); end
  def classify(table_name); end
  def constantize(camel_cased_word); end
  def dasherize(underscored_word); end
  def demodulize(class_name_in_module); end
  def foreign_key(class_name, separate_class_name_and_id_with_underscore = nil); end
  def humanize(lower_case_and_underscored_word); end
  def inflections; end
  def ordinalize(number); end
  def pluralize(word); end
  def singularize(word); end
  def tableize(class_name); end
  def titleize(word); end
  def underscore(camel_cased_word); end
  extend DataMapper::Inflector
end
class DataMapper::Inflector::Inflections
  def clear(scope = nil); end
  def human(rule, replacement); end
  def humans; end
  def initialize; end
  def irregular(singular, plural); end
  def plural(rule, replacement); end
  def plurals; end
  def self.instance; end
  def singular(rule, replacement); end
  def singulars; end
  def uncountable(*words); end
  def uncountables; end
end
module DataMapper::Chainable
  def chainable(&block); end
  def extendable(&block); end
end
module DataMapper::Deprecate
  def deprecate(old_method, new_method); end
end
class DataMapper::DescendantSet
  def <<(descendant); end
  def clear; end
  def delete(descendant); end
  def each; end
  def empty?; end
  def initialize(descendants = nil); end
  def initialize_copy(original); end
  include Enumerable
end
module DataMapper::Equalizer
  def define_eql_method(methods); end
  def define_equivalent_method(methods); end
  def define_hash_method(methods); end
  def equalize(*methods); end
end
module DataMapper::Assertions
  def assert_kind_of(name, value, *klasses); end
end
class LazyArray
  def <<(entry); end
  def ==(other); end
  def [](*args); end
  def []=(*args); end
  def any?(&block); end
  def at(index); end
  def clear; end
  def cmp?(other, operator); end
  def concat(other); end
  def delete_at(index); end
  def delete_if(&block); end
  def each; end
  def empty?; end
  def eql?(other); end
  def extract_slice_arguments(*args); end
  def fetch(*args, &block); end
  def first(*args); end
  def freeze; end
  def frozen?; end
  def head; end
  def include?(entry); end
  def index(entry); end
  def initialize; end
  def initialize_copy(original); end
  def insert(index, *entries); end
  def is_a?(klass); end
  def kind_of?(klass); end
  def last(*args); end
  def lazy_load; end
  def lazy_possible?(list, need_length = nil); end
  def load_with(&block); end
  def loaded?; end
  def mark_loaded; end
  def method_missing(method, *args, &block); end
  def pop(*args); end
  def push(*entries); end
  def replace(other); end
  def respond_to?(method, include_private = nil); end
  def reverse!; end
  def reverse; end
  def shift(*args); end
  def slice!(*args); end
  def slice(*args); end
  def splice(*args); end
  def tail; end
  def to_a; end
  def to_ary; end
  def unshift(*entries); end
  def values_at(*args); end
  include Enumerable
end
module DataMapper::LocalObjectSpace
  def object_by_id(object_id); end
  def self.extended(klass); end
end
module DataMapper::Hook
  def self.included(base); end
end
module DataMapper::Hook::ClassMethods
  def after(target_method, method_sym = nil, &block); end
  def after_class_method(target_method, method_sym = nil, &block); end
  def args_for(method); end
  def before(target_method, method_sym = nil, &block); end
  def before_class_method(target_method, method_sym = nil, &block); end
  def class_hooks; end
  def define_advised_method(target_method, scope); end
  def define_hook_stack_execution_methods(target_method, scope); end
  def hook_method_name(target_method, prefix, suffix); end
  def hooks_with_scope(scope); end
  def inline_call(method_info, scope); end
  def install_hook(type, target_method, method_sym, scope, &block); end
  def instance_hooks; end
  def method_with_scope(name, scope); end
  def process_method_added(method_name, scope); end
  def quote_method(name); end
  def register_class_hooks(*hooks); end
  def register_hook(target_method, scope); end
  def register_instance_hooks(*hooks); end
  def registered_as_hook?(target_method, scope); end
  def reset_hook!(target_method, scope); end
  def self.hook_scopes; end
  def self.hook_scopes=(arg0); end
  extend DataMapper::LocalObjectSpace
  include DataMapper::Assertions
end
module DataMapper::Subject
  def default?; end
  def default_for(resource); end
end
class DataMapper::OrderedSet
  def <<(entry); end
  def ==(other); end
  def [](index); end
  def clear; end
  def delete(entry); end
  def each; end
  def empty?; end
  def entries; end
  def eql?(other); end
  def hash; end
  def include?(entry); end
  def index(entry); end
  def initialize(entries = nil, cache = nil); end
  def initialize_copy(*arg0); end
  def merge(other); end
  def size; end
  def to_ary; end
  extend DataMapper::Equalizer
  include Enumerable
end
class DataMapper::OrderedSet::Cache
  def key_for(entry); end
  def valid?(entry); end
  include DataMapper::OrderedSet::Cache::API
end
module DataMapper::OrderedSet::Cache::API
  def [](entry); end
  def []=(entry, index); end
  def clear; end
  def delete(entry); end
  def include?(entry); end
  def initialize; end
  def key_for(entry); end
  def valid?(entry); end
end
class DataMapper::SubjectSet
  def <<(entry); end
  def [](name); end
  def clear; end
  def delete(entry); end
  def each; end
  def empty?; end
  def entries; end
  def include?(entry); end
  def initialize(entries = nil); end
  def initialize_copy(*arg0); end
  def named?(name); end
  def size; end
  def to_ary; end
  def values_at(*names); end
  include Enumerable
end
class DataMapper::SubjectSet::NameCache
  def key_for(entry); end
  def valid?(entry); end
  include DataMapper::OrderedSet::Cache::API
end
class DataMapper::Query
  def &(other); end
  def +(other); end
  def -(other); end
  def ==(other); end
  def [](*args); end
  def add_condition(condition); end
  def add_reversed?; end
  def append_condition(subject, bind_value, model = nil, operator = nil); end
  def append_operator_conditions(operator, bind_value, model); end
  def append_path(path, bind_value, model, operator); end
  def append_property_condition(subject, bind_value, operator); end
  def append_string_condition(string, bind_value, model, operator); end
  def append_symbol_condition(symbol, bind_value, model, operator); end
  def assert_valid_boolean(name, value); end
  def assert_valid_conditions(conditions); end
  def assert_valid_fields(fields, unique); end
  def assert_valid_limit(limit); end
  def assert_valid_links(links); end
  def assert_valid_offset(offset, limit); end
  def assert_valid_options(options); end
  def assert_valid_order(order, fields); end
  def assert_valid_other(other); end
  def clear; end
  def collection_for_nil(relationship); end
  def condition_properties; end
  def conditions; end
  def difference(other); end
  def each_comparison; end
  def eql?(other); end
  def equality_operator_for_type(bind_value); end
  def extract_offset_limit_from_integer(integer); end
  def extract_offset_limit_from_one_argument(arg); end
  def extract_offset_limit_from_range(range); end
  def extract_offset_limit_from_two_arguments(*args); end
  def extract_slice_arguments(*args); end
  def fields; end
  def filter_records(records); end
  def get_relative_position(offset, limit); end
  def hash; end
  def initialize(repository, model, options = nil); end
  def initialize_copy(*arg0); end
  def inspect; end
  def intersection(other); end
  def limit; end
  def limit_records(records); end
  def links; end
  def match_records(records); end
  def merge(other); end
  def merge_conditions(conditions); end
  def model; end
  def model_key; end
  def normalize_fields; end
  def normalize_links; end
  def normalize_options(options = nil); end
  def normalize_order; end
  def normalize_unique; end
  def offset; end
  def options; end
  def order; end
  def other_conditions(other, operation); end
  def query_conditions(query); end
  def raw?; end
  def record_value(record, property); end
  def relative(options); end
  def reload?; end
  def repository; end
  def reverse!; end
  def reverse; end
  def self.target_conditions(source, source_key, target_key); end
  def self.target_query(repository, model, source); end
  def self_relationship; end
  def self_relationship_options; end
  def set_operation(operation, other); end
  def slice!(*args); end
  def slice(*args); end
  def sort_records(records); end
  def sorted_fields; end
  def to_hash; end
  def to_relative_hash; end
  def to_subquery; end
  def union(other); end
  def unique?; end
  def update(other); end
  def valid?; end
  def |(other); end
  extend DataMapper::Equalizer
  include DataMapper::Assertions
end
module DataMapper::Query::Conditions
end
class DataMapper::Query::Conditions::Operation
  def self.new(slug, *operands); end
  def self.operation_class(slug); end
  def self.operation_classes; end
  def self.slugs; end
end
class DataMapper::Query::Conditions::AbstractOperation
  def &(other); end
  def +(other); end
  def -(other); end
  def <<(operand); end
  def ==(other); end
  def assert_valid_operand_type(operand); end
  def children; end
  def clear; end
  def difference(other); end
  def each; end
  def empty?; end
  def eql?(other); end
  def first; end
  def hash; end
  def initialize(*operands); end
  def initialize_copy(*arg0); end
  def intersection(other); end
  def merge(operands); end
  def minimize; end
  def minimize_operands; end
  def negated?; end
  def one?; end
  def operands; end
  def parent; end
  def parent=(arg0); end
  def prune_operands; end
  def relate_operand(operand); end
  def self.descendants; end
  def self.inherited(descendant); end
  def self.slug(slug = nil); end
  def slug; end
  def sorted_operands; end
  def to_s; end
  def union(other); end
  def valid?; end
  def valid_operand?(operand); end
  def |(other); end
  extend DataMapper::Equalizer
  include DataMapper::Assertions
  include Enumerable
end
module DataMapper::Query::Conditions::FlattenOperation
  def <<(operand); end
end
class DataMapper::Query::Conditions::AndOperation < DataMapper::Query::Conditions::AbstractOperation
  def matches?(record); end
  def minimize; end
  include DataMapper::Query::Conditions::FlattenOperation
end
class DataMapper::Query::Conditions::OrOperation < DataMapper::Query::Conditions::AbstractOperation
  def matches?(record); end
  def minimize; end
  def valid?; end
  include DataMapper::Query::Conditions::FlattenOperation
end
class DataMapper::Query::Conditions::NotOperation < DataMapper::Query::Conditions::AbstractOperation
  def <<(operand); end
  def assert_no_self_reference(operand); end
  def assert_one_operand(operand); end
  def matches?(record); end
  def minimize; end
  def negated?; end
  def operand; end
  def to_s; end
end
class DataMapper::Query::Conditions::NullOperation < DataMapper::Query::Conditions::AbstractOperation
  def initialize; end
  def inspect; end
  def matches?(record); end
  def nil?; end
  def valid?; end
end
class DataMapper::Query::Conditions::Comparison
  def self.comparison_class(slug); end
  def self.comparison_classes; end
  def self.new(slug, subject, value); end
  def self.slugs; end
end
class DataMapper::Query::Conditions::AbstractComparison
  def ==(other); end
  def dump; end
  def dump_property(value); end
  def dumped_value; end
  def eql?(other); end
  def expected(value = nil); end
  def hash; end
  def initialize(subject, value); end
  def inspect; end
  def loaded_value; end
  def match_property?(record, operator = nil); end
  def matches?(record); end
  def negated?; end
  def parent; end
  def parent=(arg0); end
  def property?; end
  def record_value(record, key_type = nil); end
  def record_value_from_hash(hash, subject, key_type); end
  def record_value_from_resource(resource, subject, key_type); end
  def relationship?; end
  def self.descendants; end
  def self.inherited(descendant); end
  def self.slug(slug = nil); end
  def slug; end
  def subject; end
  def to_s; end
  def typecast(value); end
  def typecast_property(value); end
  def valid?; end
  def valid_for_subject?(loaded_value); end
  def value; end
  extend DataMapper::Equalizer
end
module DataMapper::Query::Conditions::RelationshipHandler
  def dump; end
  def dump_relationship(value); end
  def foreign_key_mapping; end
  def match_relationship?(record); end
  def matches?(record); end
  def relationship?; end
  def typecast(value); end
end
class DataMapper::Query::Conditions::EqualToComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def matches?(record); end
  def typecast_hash(hash); end
  def typecast_relationship(value); end
  def typecast_resource(resource); end
  include DataMapper::Query::Conditions::RelationshipHandler
end
class DataMapper::Query::Conditions::InclusionComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def dump; end
  def expected; end
  def match_property?(record); end
  def typecast_collection(collection); end
  def typecast_enumerable(enumerable); end
  def typecast_hash(hash); end
  def typecast_property(value); end
  def typecast_range(range); end
  def typecast_relationship(value); end
  def typecast_resource(resource); end
  def valid?; end
  def valid_collection?(collection); end
  def valid_enumerable?(enumerable); end
  def valid_range?(range); end
  include DataMapper::Query::Conditions::RelationshipHandler
end
class DataMapper::Query::Conditions::RegexpComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def typecast(value); end
  def valid?; end
end
class DataMapper::Query::Conditions::LikeComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def expected; end
end
class DataMapper::Query::Conditions::GreaterThanComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def matches?(record); end
end
class DataMapper::Query::Conditions::LessThanComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def matches?(record); end
end
class DataMapper::Query::Conditions::GreaterThanOrEqualToComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def matches?(record); end
end
class DataMapper::Query::Conditions::LessThanOrEqualToComparison < DataMapper::Query::Conditions::AbstractComparison
  def comparator_string; end
  def matches?(record); end
end
class DataMapper::Query::Operator
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(target, operator); end
  def inspect; end
  def operator; end
  def target; end
  extend DataMapper::Equalizer
  include DataMapper::Assertions
end
class DataMapper::Query::Direction < DataMapper::Query::Operator
  def get(resource); end
  def initialize(target, operator = nil); end
  def reverse!; end
end
class DataMapper::Query::Path
  def ==(other); end
  def asc; end
  def desc; end
  def eql; end
  def eql?(other); end
  def gt; end
  def gte; end
  def hash; end
  def in; end
  def initialize(relationships, property_name = nil); end
  def instance_of?(klass); end
  def kind_of?(klass); end
  def like; end
  def lt; end
  def lte; end
  def method_missing(method, *args); end
  def model; end
  def not; end
  def property; end
  def regexp; end
  def relationships; end
  def repository_name; end
  def respond_to?(method, include_private = nil); end
  extend DataMapper::Equalizer
  include DataMapper::Assertions
end
class DataMapper::Query::Sort
  def <=>(other); end
  def direction; end
  def initialize(value, ascending = nil); end
  def value; end
end
module DataMapper::Resource
  def <=>(other); end
  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def _destroy(execute_hooks = nil); end
  def _persist; end
  def _save(execute_hooks = nil); end
  def add_to_identity_map; end
  def after_create_hook; end
  def after_destroy_hook; end
  def after_save_hook; end
  def after_update_hook; end
  def assert_not_destroyed(method); end
  def assert_save_successful(method, save_retval); end
  def assert_update_clean_only(method); end
  def attribute_dirty?(name); end
  def attribute_get(name); end
  def attribute_loaded?(name); end
  def attribute_set(name, value); end
  def attributes(key_on = nil); end
  def attributes=(attributes); end
  def before_create_hook; end
  def before_destroy_hook; end
  def before_save_hook; end
  def before_update_hook; end
  def child_associations; end
  def child_relationships; end
  def clean?; end
  def clear_subjects; end
  def cmp?(other, operator); end
  def collection; end
  def collection=(collection); end
  def collection_for_self; end
  def conditions; end
  def create_with_hooks; end
  def destroy!; end
  def destroy; end
  def destroyed?; end
  def dirty?; end
  def dirty_attributes; end
  def dirty_children?; end
  def dirty_parents?; end
  def dirty_self?; end
  def eager_load(properties); end
  def eql?(other); end
  def execute_hooks_for(type, name); end
  def fields; end
  def hash; end
  def identity_map; end
  def initialize(attributes = nil); end
  def initialize_copy(original); end
  def inspect; end
  def key; end
  def lazy_load(properties); end
  def model; end
  def new?; end
  def original_attributes; end
  def parent_associations; end
  def parent_relationships; end
  def persisted_state(*args, &block); end
  def persisted_state=(*args, &block); end
  def persisted_state?(*args, &block); end
  def persistence_state; end
  def persistence_state=(state); end
  def persistence_state?; end
  def properties; end
  def query; end
  def raise_on_save_failure; end
  def raise_on_save_failure=(raise_on_save_failure); end
  def readonly?; end
  def relationships; end
  def reload; end
  def remove_from_identity_map; end
  def repository; end
  def repository_name; end
  def reset_key; end
  def run_once(default); end
  def save!; end
  def save; end
  def save_children(execute_hooks); end
  def save_parents(execute_hooks); end
  def save_self(execute_hooks = nil); end
  def saved?; end
  def self.append_inclusions(*inclusions); end
  def self.descendants; end
  def self.extra_inclusions; end
  def self.included(model); end
  def set_default_value(subject); end
  def update!(attributes); end
  def update(attributes); end
  def update_attributes(attributes = nil, *allowed); end
  def update_with_hooks; end
  extend DataMapper::Deprecate
  include DataMapper::Assertions
end
class DataMapper::Resource::PersistenceState
  def ==(other); end
  def add_to_identity_map; end
  def commit; end
  def delete; end
  def eql?(other); end
  def get(subject, *args); end
  def hash; end
  def identity_map; end
  def initialize(resource); end
  def model; end
  def properties; end
  def relationships; end
  def remove_from_identity_map; end
  def resource; end
  def rollback; end
  def set(subject, value); end
  def set_child_key(relationship); end
  def set_child_keys; end
  extend DataMapper::Equalizer
end
class DataMapper::Resource::PersistenceState::Transient < DataMapper::Resource::PersistenceState
  def commit; end
  def create_resource; end
  def delete; end
  def get(subject, *args); end
  def original_attributes; end
  def repository; end
  def rollback; end
  def set(subject, value); end
  def set_default_value(subject); end
  def set_default_values; end
  def set_repository; end
  def track(subject); end
  def typecast_default(subject, default); end
  def valid_attributes?; end
end
class DataMapper::Resource::PersistenceState::Immutable < DataMapper::Resource::PersistenceState
  def commit; end
  def delete; end
  def get(subject, *args); end
  def rollback; end
  def set(subject, value); end
end
class DataMapper::Resource::PersistenceState::Persisted < DataMapper::Resource::PersistenceState
  def collection_for_self; end
  def get(subject, *args); end
  def lazy_load(subject); end
  def repository; end
end
class DataMapper::Resource::PersistenceState::Clean < DataMapper::Resource::PersistenceState::Persisted
  def commit; end
  def delete; end
  def not_modified?(subject, value); end
  def rollback; end
  def set(subject, value); end
end
class DataMapper::Resource::PersistenceState::Deleted < DataMapper::Resource::PersistenceState::Persisted
  def commit; end
  def delete; end
  def delete_resource; end
  def set(subject, value); end
end
class DataMapper::Resource::PersistenceState::Dirty < DataMapper::Resource::PersistenceState::Persisted
  def commit; end
  def delete; end
  def original_attributes; end
  def reset_original_attributes; end
  def reset_resource; end
  def reset_resource_key; end
  def reset_resource_properties; end
  def reset_resource_relationships; end
  def rollback; end
  def set(subject, value); end
  def track(subject, value); end
  def update_resource; end
  def valid_attributes?; end
end
class DataMapper::Property
  def ==(other); end
  def allow_blank; end
  def allow_blank?; end
  def allow_nil; end
  def allow_nil?; end
  def assert_valid_options(options); end
  def bind; end
  def default; end
  def determine_visibility; end
  def eql?(other); end
  def field(repository_name = nil); end
  def get!(resource); end
  def get(resource); end
  def hash; end
  def index; end
  def initialize(model, name, options = nil); end
  def inspect; end
  def instance_variable_name; end
  def key?; end
  def lazy?; end
  def lazy_load(resource); end
  def lazy_load_properties; end
  def loaded?(resource); end
  def model; end
  def name; end
  def options; end
  def primitive; end
  def primitive?(value); end
  def properties; end
  def reader_visibility; end
  def repository_name; end
  def required; end
  def required?; end
  def self.accept_options(*args); end
  def self.accepted_options; end
  def self.accessor(value = nil); end
  def self.all_descendants(*args, &block); end
  def self.allow_blank(value = nil); end
  def self.allow_nil(value = nil); end
  def self.default(value = nil); end
  def self.demodulized_names; end
  def self.descendants; end
  def self.determine_class(type); end
  def self.field(value = nil); end
  def self.find_class(name); end
  def self.index(value = nil); end
  def self.inherited(descendant); end
  def self.key(value = nil); end
  def self.lazy(value = nil); end
  def self.nullable(*args); end
  def self.options; end
  def self.primitive(value = nil); end
  def self.reader(value = nil); end
  def self.required(value = nil); end
  def self.unique(value = nil); end
  def self.unique_index(value = nil); end
  def self.writer(value = nil); end
  def serial?; end
  def set!(resource, value); end
  def set(resource, value); end
  def typecast(value); end
  def unique?; end
  def unique_index; end
  def valid?(value, negated = nil); end
  def writer_visibility; end
  extend DataMapper::Equalizer
  include DataMapper::Assertions
  include DataMapper::Subject
end
module DataMapper::Property::PassThroughLoadDump
  def dump(value); end
  def load(value); end
end
module DataMapper::Property::Typecast
end
module DataMapper::Property::Typecast::Numeric
  def typecast_to_numeric(value, method); end
end
module DataMapper::Property::Typecast::Time
  def extract_time(value); end
  include DataMapper::Property::Typecast::Numeric
end
class DataMapper::Property::Object < DataMapper::Property
  def dump(value); end
  def load(value); end
  def to_child_key; end
end
class DataMapper::Property::String < DataMapper::Property::Object
  def initialize(model, name, options = nil); end
  def length; end
  def self.length(value = nil); end
  def typecast_to_primitive(value); end
  include DataMapper::Property::PassThroughLoadDump
end
class DataMapper::Property::Binary < DataMapper::Property::String
  def dump(value); end
  def load(value); end
  include DataMapper::Property::PassThroughLoadDump
end
class DataMapper::Property::Text < DataMapper::Property::String
  def primitive?(value); end
end
class DataMapper::Property::Numeric < DataMapper::Property::Object
  def initialize(model, name, options = nil); end
  def max; end
  def min; end
  def precision; end
  def scale; end
  def self.max(value = nil); end
  def self.min(value = nil); end
  def self.precision(value = nil); end
  def self.scale(value = nil); end
  include DataMapper::Property::PassThroughLoadDump
  include DataMapper::Property::Typecast::Numeric
end
class DataMapper::Property::Float < DataMapper::Property::Numeric
  def typecast_to_primitive(value); end
end
class DataMapper::Property::Decimal < DataMapper::Property::Numeric
  def initialize(model, name, options = nil); end
  def typecast_to_primitive(value); end
end
class DataMapper::Property::Boolean < DataMapper::Property::Object
  def primitive?(value); end
  def typecast_to_primitive(value); end
  include DataMapper::Property::PassThroughLoadDump
end
class DataMapper::Property::Integer < DataMapper::Property::Numeric
  def initialize(model, name, options = nil); end
  def self.serial(value = nil); end
  def typecast_to_primitive(value); end
end
class DataMapper::Property::Serial < DataMapper::Property::Integer
  def to_child_key; end
end
class DataMapper::Property::Date < DataMapper::Property::Object
  def typecast_hash_to_date(value); end
  def typecast_to_primitive(value); end
  include DataMapper::Property::PassThroughLoadDump
  include DataMapper::Property::Typecast::Time
end
class DataMapper::Property::DateTime < DataMapper::Property::Object
  def typecast_hash_to_datetime(value); end
  def typecast_to_primitive(value); end
  include DataMapper::Property::PassThroughLoadDump
  include DataMapper::Property::Typecast::Time
end
class DataMapper::Property::Time < DataMapper::Property::Object
  def typecast_hash_to_time(value); end
  def typecast_to_primitive(value); end
  include DataMapper::Property::PassThroughLoadDump
  include DataMapper::Property::Typecast::Time
end
class DataMapper::Property::Class < DataMapper::Property::Object
  def typecast_to_primitive(value); end
  include DataMapper::Property::PassThroughLoadDump
end
class DataMapper::Property::Discriminator < DataMapper::Property::Class
  def bind; end
  include DataMapper::Property::PassThroughLoadDump
end
module DataMapper::Property::Discriminator::Model
  def inherited(model); end
  def new(*args, &block); end
  def set_discriminator_scope_for(model); end
end
module DataMapper::Property::Lookup
  def const_missing(name); end
end
class DataMapper::PropertySet < DataMapper::SubjectSet
  def &(other); end
  def +(other); end
  def -(other); end
  def <<(property); end
  def ==(other); end
  def []=(name, entry); end
  def clear_cache; end
  def defaults; end
  def discriminator; end
  def field_map; end
  def get!(resource); end
  def get(resource); end
  def in_context(properties); end
  def indexes; end
  def inspect; end
  def key; end
  def lazy_context(context); end
  def lazy_contexts; end
  def loaded?(resource); end
  def parse_index(index, property, index_hash); end
  def property_contexts(property); end
  def set!(resource, values); end
  def set(resource, values); end
  def typecast(values); end
  def unique_indexes; end
  def valid?(values); end
  def |(other); end
  include Enumerable
end
module DataMapper::Model
  def [](*args); end
  def _create(attributes, execute_hooks = nil); end
  def all(query = nil); end
  def allowed_writer_methods; end
  def assert_valid(force = nil); end
  def assert_valid_key; end
  def assert_valid_key_size(key); end
  def assert_valid_name; end
  def assert_valid_properties; end
  def at(*args); end
  def base_model; end
  def const_missing(name); end
  def copy(source_repository_name, target_repository_name, query = nil); end
  def create!(attributes = nil); end
  def create(attributes = nil); end
  def default_order(repository_name = nil); end
  def default_repository_name; end
  def default_storage_name; end
  def descendants; end
  def destroy!; end
  def destroy; end
  def each(&block); end
  def fetch(*args, &block); end
  def finalize; end
  def finalize_allowed_writer_methods; end
  def finalize_relationships; end
  def first(*args); end
  def first_or_create(conditions = nil, attributes = nil); end
  def first_or_new(conditions = nil, attributes = nil); end
  def get!(*key); end
  def get(*key); end
  def inherited(descendant); end
  def last(*args); end
  def load(records, query); end
  def new_collection(query, resources = nil, &block); end
  def raise_on_save_failure; end
  def raise_on_save_failure=(raise_on_save_failure); end
  def repositories; end
  def repository(name = nil, &block); end
  def repository_name; end
  def reverse; end
  def scoped_query(query); end
  def self.append_extensions(*extensions); end
  def self.append_inclusions(*inclusions); end
  def self.descendants; end
  def self.extended(descendant); end
  def self.extra_extensions; end
  def self.extra_inclusions; end
  def self.new(name = nil, namespace = nil, &block); end
  def self.raise_on_save_failure; end
  def self.raise_on_save_failure=(raise_on_save_failure); end
  def slice(*args); end
  def storage_name(repository_name = nil); end
  def storage_names; end
  def update!(attributes); end
  def update(attributes); end
  def values_at(*args); end
  include DataMapper::Model::Is
  include DataMapper::Model::Scope
  include Enumerable
end
module DataMapper::Model::Hook
  def self.included(model); end
  extend DataMapper::Chainable
end
module DataMapper::Model::Hook::Methods
  def after(target_method, method_sym = nil, &block); end
  def before(target_method, method_sym = nil, &block); end
  def copy_hooks(model); end
  def hooks; end
  def inherited(model); end
  def setup_hook(type, name, method, proc); end
end
class DataMapper::Model::Hook::ProcCommand
  def call(resource); end
  def copy(model); end
  def initialize(proc); end
end
class DataMapper::Model::Hook::MethodCommand
  def call(resource); end
  def copy(model); end
  def initialize(model, method); end
end
module DataMapper::Model::Is
  def is(plugin, *args, &block); end
end
module DataMapper::Model::Scope
  def current_scope; end
  def default_scope(repository_name = nil); end
  def query; end
  def scope_stack; end
  def with_exclusive_scope(query); end
  def with_scope(query); end
end
module DataMapper::Model::Relationship
  def assert_valid_options(options); end
  def belongs_to(name, *args); end
  def create_relationship_reader(relationship); end
  def create_relationship_writer(relationship); end
  def extract_min_max(cardinality); end
  def extract_model(args); end
  def extract_options(args); end
  def has(cardinality, name, *args); end
  def inherited(model); end
  def method_missing(method, *args, &block); end
  def n; end
  def relationship_module; end
  def relationships(repository_name = nil); end
  def self.extended(model); end
  include DataMapper::Assertions
end
module DataMapper::Model::Property
  def create_reader_for(property); end
  def create_writer_for(property); end
  def field_naming_convention(repository_name = nil); end
  def inherited(model); end
  def key(repository_name = nil); end
  def key_conditions(repository, key); end
  def method_missing(method, *args, &block); end
  def properties(repository_name = nil); end
  def properties_with_subclasses(repository_name = nil); end
  def property(name, type, options = nil); end
  def property_module; end
  def self.extended(model); end
  def serial(repository_name = nil); end
end
class DataMapper::Collection < LazyArray
  def &(other); end
  def +(other); end
  def -(other); end
  def <<(resource); end
  def [](*args); end
  def []=(*args); end
  def _create(attributes, execute_hooks = nil); end
  def _save(execute_hooks = nil); end
  def _update(dirty_attributes); end
  def all(query = nil); end
  def assert_update_clean_only(method); end
  def assert_valid_key_size(key); end
  def at(offset); end
  def blank?; end
  def clean?; end
  def clear; end
  def collect!; end
  def concat(resources); end
  def create!(attributes = nil); end
  def create(attributes = nil); end
  def default_attributes; end
  def delegate_to_model(method, *args, &block); end
  def delegate_to_relationship(relationship, query = nil); end
  def delete(resource); end
  def delete_at(offset); end
  def delete_if; end
  def destroy!; end
  def destroy; end
  def difference(other); end
  def dirty?; end
  def each; end
  def filter(other_query); end
  def first(*args); end
  def first_or_create(conditions = nil, attributes = nil); end
  def first_or_new(conditions = nil, attributes = nil); end
  def get!(*key); end
  def get(*key); end
  def hash; end
  def initialize(query, resources = nil); end
  def initialize_copy(original); end
  def initialize_resource(resource); end
  def insert(offset, *resources); end
  def inspect; end
  def intersection(other); end
  def last(*args); end
  def lazy_load; end
  def loaded_entries; end
  def map!; end
  def method_missing(method, *args, &block); end
  def model; end
  def model_key; end
  def new(attributes = nil); end
  def new_collection(query, resources = nil, &block); end
  def partially_loaded?(offset, limit = nil); end
  def pop(*arg0); end
  def properties; end
  def push(*resources); end
  def query; end
  def reject!; end
  def relationships; end
  def reload(other_query = nil); end
  def replace(other); end
  def repository; end
  def repository_name; end
  def resource_added(resource); end
  def resource_removed(resource); end
  def resources_added(resources); end
  def resources_removed(resources); end
  def respond_to?(method, include_private = nil); end
  def reverse!; end
  def reverse; end
  def save!; end
  def save; end
  def scoped_query(query); end
  def set(resources); end
  def set_default_attributes(resource); end
  def set_operation(operation, other); end
  def set_operation_resources(operation, other); end
  def shift(*arg0); end
  def slice!(*args); end
  def slice(*args); end
  def sliced_query(offset, limit); end
  def splice(*args); end
  def superclass_replace(other); end
  def superclass_slice(*args); end
  def union(other); end
  def unshift(*resources); end
  def update!(attributes); end
  def update(attributes); end
  def |(other); end
end
class DataMapper::RelationshipSet < DataMapper::SubjectSet
  def each_value; end
  def has_key?(name); end
  def key?(name); end
  def values; end
end
module DataMapper::Associations
end
class DataMapper::Associations::Relationship
  def ==(other); end
  def associate_targets(source, targets); end
  def child_key; end
  def child_model; end
  def child_model?; end
  def child_model_name; end
  def child_properties; end
  def child_repository_name; end
  def cmp?(other, operator); end
  def cmp_key?(other, operator, type); end
  def cmp_model?(other, operator, type); end
  def cmp_repository?(other, operator, type); end
  def eager_load(source, query = nil); end
  def eager_load_targets(source, targets, query); end
  def eql?(other); end
  def field; end
  def get!(resource); end
  def get(resource, other_query = nil); end
  def hash; end
  def initialize(name, child_model, parent_model, options = nil); end
  def initialize_object_ivar(name, object); end
  def instance_variable_name; end
  def inverse; end
  def inverse?(other); end
  def inverse_name; end
  def invert; end
  def inverted_options; end
  def kind_of_inverse?(other); end
  def loaded?(resource); end
  def max; end
  def min; end
  def name; end
  def options; end
  def parent_key; end
  def parent_model; end
  def parent_model?; end
  def parent_model_name; end
  def parent_properties; end
  def parent_repository_name; end
  def query; end
  def query_for(source, other_query = nil); end
  def reader_visibility; end
  def relationship_child_key; end
  def relative_target_repository_name; end
  def relative_target_repository_name_for(source); end
  def set!(resource, association); end
  def set(resource, association); end
  def source_scope(source); end
  def valid?(value, negated = nil); end
  def valid_source?(source); end
  def valid_target?(target); end
  def valid_target_collection?(collection, negated); end
  def writer_visibility; end
  include DataMapper::Assertions
  include DataMapper::Subject
end
module DataMapper::Associations::OneToMany
end
class DataMapper::Associations::OneToMany::Relationship < DataMapper::Associations::Relationship
  def child_key; end
  def child_properties; end
  def collection_class; end
  def collection_for(source, other_query = nil); end
  def default_for(source); end
  def eager_load_targets(source, targets, query); end
  def finalize; end
  def get(source, query = nil); end
  def get_collection(source); end
  def initialize(name, target_model, source_model, options = nil); end
  def inverse_class; end
  def inverse_name; end
  def lazy_load(source); end
  def set(source, targets); end
  def set_collection(source, target); end
  def source_key; end
  def source_model; end
  def source_repository_name; end
  def target_key; end
  def target_model; end
  def target_repository_name; end
end
class DataMapper::Associations::OneToMany::Collection < DataMapper::Collection
  def _create(*arg0); end
  def _save(execute_hooks = nil); end
  def assert_source_saved(message); end
  def clear; end
  def destroy!; end
  def destroy; end
  def inverse_set(source, target); end
  def lazy_load; end
  def new_collection(query, resources = nil, &block); end
  def relationship; end
  def relationship=(arg0); end
  def reload(*arg0); end
  def replace(*arg0); end
  def resource_added(resource); end
  def resource_removed(resource); end
  def source; end
  def source=(arg0); end
  def update!(*arg0); end
  def update(*arg0); end
end
module DataMapper::Associations::OneToOne
end
class DataMapper::Associations::OneToOne::Relationship < DataMapper::Associations::Relationship
  def default_for(source); end
  def get!(source); end
  def get(source, query = nil); end
  def initialize(name, target_model, source_model, options = nil); end
  def instance_of?(klass); end
  def kind_of?(klass); end
  def method_missing(method, *args, &block); end
  def relationship; end
  def respond_to?(method, include_private = nil); end
  def set!(source, target); end
  def set(source, target); end
end
module DataMapper::Associations::ManyToOne
end
class DataMapper::Associations::ManyToOne::Relationship < DataMapper::Associations::Relationship
  def child_key; end
  def child_properties; end
  def default_for(source); end
  def eager_load_targets(source, targets, query); end
  def finalize; end
  def get(source, query = nil); end
  def get_collection(source); end
  def initialize(name, source_model, target_model, options = nil); end
  def inverse_class; end
  def inverse_name; end
  def key?; end
  def lazy_load(source); end
  def nullable?; end
  def required?; end
  def resource_for(source, other_query = nil); end
  def set(source, target); end
  def source_key; end
  def source_key_different?(source); end
  def source_key_dirty?(source); end
  def source_key_options(target_property); end
  def source_model; end
  def source_repository_name; end
  def source_scope(source); end
  def target_key; end
  def target_model; end
  def target_repository_name; end
  def typecast(target); end
  def unique?; end
end
module DataMapper::Associations::ManyToMany
end
class DataMapper::Associations::ManyToMany::Relationship < DataMapper::Associations::OneToMany::Relationship
  def anonymous_through_model?; end
  def child_key; end
  def collection_class; end
  def eager_load(source, other_query = nil); end
  def finalize; end
  def inverse_class; end
  def invert; end
  def inverted_options; end
  def links; end
  def nearest_relationship; end
  def query; end
  def source_scope(source); end
  def target_key; end
  def through; end
  def through_model; end
  def through_model_namespace_name; end
  def through_relationship_name; end
  def valid_source?(source); end
  def valid_target?(target); end
  def via; end
  extend DataMapper::Chainable
  include Anonymous_Module_4
end
module Anonymous_Module_4
  def many_to_one_options; end
  def one_to_many_options; end
end
class DataMapper::Associations::ManyToMany::Collection < DataMapper::Associations::OneToMany::Collection
  def _create(attributes, execute_hooks = nil); end
  def _save(execute_hooks = nil); end
  def create_intermediary(execute_hooks, resource = nil); end
  def destroy!; end
  def destroy; end
  def intermediaries; end
  def intermediary_for; end
  def inverse_set(*arg0); end
  def reset_intermediaries; end
  def through; end
  def via; end
end
class DataMapper::IdentityMap < Hash
end
class DataMapper::Repository
  def ==(other); end
  def adapter; end
  def create(resources); end
  def delete(collection); end
  def eql?(other); end
  def hash; end
  def identity_map(model); end
  def initialize(name); end
  def inspect; end
  def name; end
  def new_query(model, options = nil); end
  def read(query); end
  def scope; end
  def self.adapters; end
  def self.context; end
  def self.default_name; end
  def to_sym; end
  def update(attributes, collection); end
  extend DataMapper::Equalizer
  include DataMapper::Assertions
end
module DataMapper::Adapters
  def self.adapter_class(name); end
  def self.adapter_name(const_name); end
  def self.in_memory_adapter?(name); end
  def self.in_memory_adapter_path; end
  def self.in_memory_adapter_path=(path); end
  def self.legacy_path(name); end
  def self.load_adapter(name); end
  def self.new(repository_name, options); end
  def self.normalize_adapter_name(name); end
  def self.normalize_options(options); end
  def self.normalize_options_hash(hash); end
  def self.normalize_options_string(string); end
  def self.normalize_options_uri(uri); end
  extend Anonymous_Module_5
  extend DataMapper::Assertions
  extend DataMapper::Chainable
end
module Anonymous_Module_5
  def const_added(const_name); end
end
class DataMapper::Adapters::AbstractAdapter
  def ==(other); end
  def attributes_as_fields(attributes); end
  def create(resources); end
  def delete(collection); end
  def eql?(other); end
  def field_naming_convention; end
  def field_naming_convention=(arg0); end
  def hash; end
  def initialize(name, options); end
  def initialize_serial(resource, next_id); end
  def name; end
  def new_query(repository, model, options = nil); end
  def options; end
  def read(query); end
  def resource_naming_convention; end
  def resource_naming_convention=(arg0); end
  def self.descendants; end
  def self.inherited(descendant); end
  def update(attributes, collection); end
  extend DataMapper::Assertions
  extend DataMapper::Equalizer
  include DataMapper::Assertions
end
class DataMapper::Logger
  def <<(string = nil); end
  def auto_flush; end
  def auto_flush=(arg0); end
  def buffer; end
  def close; end
  def debug!(message = nil); end
  def debug(message = nil); end
  def debug?; end
  def delimiter; end
  def delimiter=(arg0); end
  def error!(message = nil); end
  def error(message = nil); end
  def error?; end
  def fatal!(message = nil); end
  def fatal(message = nil); end
  def fatal?; end
  def flush; end
  def info!(message = nil); end
  def info(message = nil); end
  def info?; end
  def init_args; end
  def initialize(*args); end
  def initialize_log(log); end
  def level; end
  def level=(arg0); end
  def log; end
  def push(string = nil); end
  def set_log(log, log_level = nil, delimiter = nil, auto_flush = nil); end
  def warn!(message = nil); end
  def warn(message = nil); end
  def warn?; end
end
module DataMapper::NamingConventions
end
module DataMapper::NamingConventions::Resource
end
module DataMapper::NamingConventions::Resource::UnderscoredAndPluralized
  def self.call(name); end
end
module DataMapper::NamingConventions::Resource::UnderscoredAndPluralizedWithoutModule
  def self.call(name); end
end
module DataMapper::NamingConventions::Resource::UnderscoredAndPluralizedWithoutLeadingModule
  def self.call(name); end
end
module DataMapper::NamingConventions::Resource::Underscored
  def self.call(name); end
end
module DataMapper::NamingConventions::Resource::Yaml
  def self.call(name); end
end
module DataMapper::NamingConventions::Field
end
module DataMapper::NamingConventions::Field::UnderscoredAndPluralized
  def self.call(property); end
end
module DataMapper::NamingConventions::Field::UnderscoredAndPluralizedWithoutModule
  def self.call(property); end
end
module DataMapper::NamingConventions::Field::Underscored
  def self.call(property); end
end
module DataMapper::NamingConventions::Field::Yaml
  def self.call(property); end
end
module Kernel
  def repository(*args, &block); end
end
class Symbol
  def asc; end
  def desc; end
  def eql; end
  def gt; end
  def gte; end
  def in; end
  def like; end
  def lt; end
  def lte; end
  def not; end
  def regexp; end
end
module DataMapper::Undefined
end
class DataMapper::RepositoryNotSetupError < StandardError
end
class DataMapper::IncompleteModelError < StandardError
end
class DataMapper::PluginNotFoundError < StandardError
end
class DataMapper::UnknownRelationshipError < StandardError
end
class DataMapper::ObjectNotFoundError < RuntimeError
end
class DataMapper::PersistenceError < RuntimeError
end
class DataMapper::UpdateConflictError < DataMapper::PersistenceError
end
class DataMapper::SaveFailureError < DataMapper::PersistenceError
  def initialize(message, resource); end
  def resource; end
end
class DataMapper::ImmutableError < RuntimeError
end
class DataMapper::ImmutableDeletedError < DataMapper::ImmutableError
end
class DataMapper::UnsavedParentError < DataMapper::PersistenceError
end
