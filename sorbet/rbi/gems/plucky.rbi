# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/plucky/all/plucky.rbi
#
# plucky-0.7.0
class Object < BasicObject
  def duplicable?; end
end
class NilClass
  def duplicable?; end
end
class FalseClass
  def duplicable?; end
end
class TrueClass
  def duplicable?; end
end
class Symbol
  def duplicable?; end
  include Plucky::Extensions::Symbol
end
class Numeric
  def duplicable?; end
end
class Class < Module
  def duplicable?; end
end
class Module
  def duplicable?; end
end
module Plucky
  def self.modifier?(key); end
  def self.to_object_id(value); end
end
module Plucky::Extensions
end
module Plucky::Extensions::Symbol
  def all; end
  def asc; end
  def desc; end
  def exists; end
  def gt; end
  def gte; end
  def in; end
  def lt; end
  def lte; end
  def mod; end
  def ne; end
  def nin; end
  def size; end
end
class SymbolOperator
  def <=>(other); end
  def ==(other); end
  def eql?(other); end
  def field; end
  def hash; end
  def initialize(field, operator, options = nil); end
  def operator; end
  include Comparable
end
module Plucky::Normalizers
end
class Plucky::Normalizers::CriteriaHashValue
  def call(parent_key, key, value); end
  def criteria_hash_class; end
  def initialize(criteria_hash); end
  def modifier?(key); end
  def nesting_operator?(key); end
  def object_id?(key); end
  def options; end
  def to_object_id(value); end
end
class Plucky::Normalizers::CriteriaHashKey
  def call(key); end
end
class Plucky::CriteriaHash
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def array(value); end
  def hash_merge(oldhash, newhash); end
  def initialize(hash = nil, options = nil); end
  def initialize_copy(original); end
  def key_normalizer; end
  def keys; end
  def merge!(other); end
  def merge(other); end
  def merge_compound_or_clauses!(oldhash, newhash); end
  def merge_values_into_array(value, other_value); end
  def modifier_merge(hash, value); end
  def normalized_key(key); end
  def normalized_value(parent_key, key, value); end
  def object_id?(key); end
  def object_ids; end
  def object_ids=(value); end
  def options; end
  def simple?; end
  def source; end
  def to_hash; end
  def value_normalizer; end
end
class Plucky::Normalizers::HashKey
  def call(key); end
  def initialize(keys); end
end
class Plucky::Normalizers::Integer
  def call(value); end
end
class Plucky::Normalizers::FieldsValue
  def call(value); end
end
class Plucky::Normalizers::SortValue
  def call(value); end
  def initialize(args = nil); end
  def normalized_direction(field, direction = nil); end
  def normalized_sort_piece(value); end
end
class Plucky::Normalizers::OptionsHashValue
  def call(key, value); end
  def default_fields_value_normalizer; end
  def default_limit_value_normalizer; end
  def default_skip_value_normalizer; end
  def default_sort_value_normalizer; end
  def initialize(args = nil); end
end
class Plucky::OptionsHash
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def fields?; end
  def initialize(hash = nil, options = nil); end
  def initialize_copy(original); end
  def key_normalizer; end
  def keys; end
  def merge!(other); end
  def merge(other); end
  def normalized_key(key); end
  def normalized_value(key, value); end
  def options; end
  def source; end
  def to_hash; end
  def value_normalizer; end
end
class Plucky::Query
  def [](key); end
  def []=(key, value); end
  def amend(opts = nil); end
  def collection; end
  def criteria; end
  def criteria_hash; end
  def cursor(&block); end
  def explain; end
  def fields?(*args, &block); end
  def hash_for_key(key); end
  def include?(*args, &block); end
  def initialize(collection, query_options = nil); end
  def initialize_copy(original); end
  def inspect; end
  def merge(other); end
  def object_ids(*keys); end
  def options; end
  def options_hash; end
  def options_key?(key); end
  def set_field_inclusion(fields, value); end
  def simple?(*args, &block); end
  def symbolized_key(key); end
  def to_hash; end
  def update(document, driver_opts = nil); end
  extend Forwardable
  include Enumerable
  include Plucky::Query::DSL
end
module Plucky::Query::DSL
  def all(opts = nil); end
  def count(opts = nil); end
  def distinct(key, opts = nil); end
  def each(opts = nil); end
  def empty?; end
  def exist?(query_options = nil); end
  def exists?(query_options = nil); end
  def fields(*args); end
  def filter(hash = nil); end
  def find(*ids); end
  def find_each(opts = nil); end
  def find_one(opts = nil); end
  def first(opts = nil); end
  def ignore(*args); end
  def last(opts = nil); end
  def limit(count = nil); end
  def offset(count = nil); end
  def only(*args); end
  def order(*args); end
  def paginate(opts = nil); end
  def per_page(limit = nil); end
  def remove(opts = nil, driver_opts = nil); end
  def reverse; end
  def size(opts = nil); end
  def skip(count = nil); end
  def sort(*args); end
  def to_a(opts = nil); end
  def where(hash = nil); end
end
module Plucky::Pagination
end
class Plucky::Pagination::Collection < Array
  def current_page(*args, &block); end
  def initialize(records, paginator); end
  def limit(*args, &block); end
  def method_missing(method, *args); end
  def next_page(*args, &block); end
  def offset(*args, &block); end
  def out_of_bounds?(*args, &block); end
  def paginator(p = nil); end
  def per_page(*args, &block); end
  def previous_page(*args, &block); end
  def skip(*args, &block); end
  def total_entries(*args, &block); end
  def total_pages(*args, &block); end
  extend Forwardable
end
class Plucky::Pagination::Paginator
  def current_page; end
  def initialize(total, page, per_page = nil); end
  def limit; end
  def next_page; end
  def offset; end
  def out_of_bounds?; end
  def per_page; end
  def previous_page; end
  def skip; end
  def total_entries; end
  def total_pages; end
end
